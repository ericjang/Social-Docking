var file_1 = '\n OpenBabel01091220403D\n\n 40 41  0  0  0  0  0  0  0  0999 V2000\n   -5.0824   -3.0865    0.2048 C   0  0  0  0  0  0  0  0  0  0  0  0\n   -4.4771   -1.8238    0.8211 C   0  0  0  0  0  0  0  0  0  0  0  0\n   -3.7325   -1.0358   -0.2585 C   0  0  0  0  0  0  0  0  0  0  0  0\n   -3.0147    0.4613    0.4722 S   0  0  2  0  0  0  0  0  0  0  0  0\n   -4.0569    1.3057    0.9415 O   0  0  0  0  0  0  0  0  0  0  0  0\n   -2.1881    1.2478   -0.9380 C   0  0  1  0  0  0  0  0  0  0  0  0\n   -1.4542    2.4930   -0.4516 C   0  0  0  0  0  0  0  0  0  0  0  0\n   -0.2790    2.1366    0.4800 C   0  0  0  0  0  0  0  0  0  0  0  0\n    0.6327    1.2244   -0.3136 C   0  0  2  0  0  0  0  0  0  0  0  0\n   -0.1667   -0.0837   -0.5644 C   0  0  1  0  0  0  0  0  0  0  0  0\n   -1.2300    0.2322   -1.5872 C   0  0  0  0  0  0  0  0  0  0  0  0\n    0.8897   -1.0252   -0.8657 N   0  0  0  0  0  0  0  0  0  0  0  0\n    0.7978   -1.8587   -1.3532 H   0  0  0  0  0  0  0  0  0  0  0  0\n    2.0502   -0.5140   -0.3300 C   0  0  0  0  0  0  0  0  0  0  0  0\n    3.2347   -1.0978   -0.4259 N   0  0  0  0  0  0  0  0  0  0  0  0\n    4.3100   -0.5249    0.1282 C   0  0  0  0  0  0  0  0  0  0  0  0\n    4.1989    0.5330    0.7202 O   0  0  0  0  0  0  0  0  0  0  0  0\n    5.5173   -1.1199    0.0304 O   0  0  0  0  0  0  0  0  0  0  0  0\n    6.6212   -0.4524    0.6453 C   0  0  0  0  0  0  0  0  0  0  0  0\n    1.8249    0.6834    0.3203 N   0  0  0  0  0  0  0  0  0  0  0  0\n    2.3452    1.0757    1.0388 H   0  0  0  0  0  0  0  0  0  0  0  0\n   -5.7784   -2.8071   -0.5862 H   0  0  0  0  0  0  0  0  0  0  0  0\n   -4.2872   -3.7043   -0.2125 H   0  0  0  0  0  0  0  0  0  0  0  0\n   -5.6129   -3.6479    0.9739 H   0  0  0  0  0  0  0  0  0  0  0  0\n   -5.2723   -1.2060    1.2384 H   0  0  0  0  0  0  0  0  0  0  0  0\n   -3.7811   -2.1032    1.6121 H   0  0  0  0  0  0  0  0  0  0  0  0\n   -2.9373   -1.6536   -0.6758 H   0  0  0  0  0  0  0  0  0  0  0  0\n   -4.4284   -0.7564   -1.0495 H   0  0  0  0  0  0  0  0  0  0  0  0\n   -1.0711    3.0390   -1.3137 H   0  0  0  0  0  0  0  0  0  0  0  0\n    0.2563    3.0409    0.7695 H   0  0  0  0  0  0  0  0  0  0  0  0\n   -1.7729   -0.6751   -1.8520 H   0  0  0  0  0  0  0  0  0  0  0  0\n    6.7439    0.5342    0.1985 H   0  0  0  0  0  0  0  0  0  0  0  0\n    6.4325   -0.3465    1.7136 H   0  0  0  0  0  0  0  0  0  0  0  0\n    7.5292   -1.0358    0.4928 H   0  0  0  0  0  0  0  0  0  0  0  0\n   -2.9399    1.5425   -1.6702 H   0  0  0  0  0  0  0  0  0  0  0  0\n   -2.1547    3.1302    0.0880 H   0  0  0  0  0  0  0  0  0  0  0  0\n   -0.6475    1.6189    1.3656 H   0  0  0  0  0  0  0  0  0  0  0  0\n    0.8885    1.6918   -1.2645 H   0  0  0  0  0  0  0  0  0  0  0  0\n   -0.6457   -0.3893    0.3658 H   0  0  0  0  0  0  0  0  0  0  0  0\n   -0.7736    0.6670   -2.4765 H   0  0  0  0  0  0  0  0  0  0  0  0\n  1  2  1  0  0  0  0\n  1 22  1  0  0  0  0\n  1 23  1  0  0  0  0\n  1 24  1  0  0  0  0\n  2  3  1  0  0  0  0\n  2 25  1  0  0  0  0\n  2 26  1  0  0  0  0\n  3 27  1  0  0  0  0\n  3 28  1  0  0  0  0\n  4  3  1  6  0  0  0\n  4  5  2  0  0  0  0\n  4  6  1  0  0  0  0\n  6  7  1  0  0  0  0\n  6 11  1  0  0  0  0\n  6 35  1  6  0  0  0\n  7  8  1  0  0  0  0\n  7 29  1  0  0  0  0\n  7 36  1  0  0  0  0\n  8  9  1  0  0  0  0\n  8 30  1  0  0  0  0\n  8 37  1  0  0  0  0\n  9 10  1  0  0  0  0\n  9 20  1  0  0  0  0\n  9 38  1  6  0  0  0\n 10 11  1  0  0  0  0\n 10 12  1  0  0  0  0\n 10 39  1  1  0  0  0\n 11 31  1  0  0  0  0\n 11 40  1  0  0  0  0\n 12 13  1  0  0  0  0\n 12 14  1  0  0  0  0\n 14 15  2  0  0  0  0\n 14 20  1  0  0  0  0\n 15 16  1  0  0  0  0\n 16 17  2  0  0  0  0\n 16 18  1  0  0  0  0\n 18 19  1  0  0  0  0\n 19 32  1  0  0  0  0\n 19 33  1  0  0  0  0\n 19 34  1  0  0  0  0\n 20 21  1  0  0  0  0\nM  END\n'

var testligand = ChemDoodle.readMOL(file_1,1);

function MCMC_Search(smiles,docking_job) {
	
	var ligand;
// 	ChemDoodle.iChemLabs.readSMILES(smiles, function(mol){
// 	    var molstring = ChemDoodle.writeMOL(mol);
// 	    ligand = ChemDoodle.readMOL(molstring,1);
// 	});	

	ligand = testligand;
	var receptor = docking_job.receptor,
		totalEnergy = 0,
		center = ligand.getCenter3D();//returns the atom that is approx in center of molecule.

	moveMoleculeTo(ligand,docking_job.startingpoint);
	//assign atom types and partial charges and other metadata setup stuff
	setupMetadata2(ligand);
	//perform the metropolis monte carlo search using the GAFF force field as scoring function for number of steps
	var energy = computeEnergy(ligand,receptor);
	for (i = 0; i <docking_job.iterations;i++) {
		var backup = ghostcopy(ligand);
		//monte carlo move on ligand
		montecarlomove(ligand,docking_job.startingpoint);
		//compute energy of new system
		var newenergy = computeEnergy(ligand,receptor);
		//various debugging code
		var deltaE = newenergy - energy;
		if (deltaE < 0) {
			energy = newenergy;//newenergy becomes smallest energy	
		} else {
			//evaluate the metropolis criterion and determine if keep or toss
			var R = Math.random()
			//evaluate the relative probability of a state in the boltzmann distribution
			var prob = Math.exp(-deltaE/(BOLTZMANN_CONST*TEMPERATURE));
			if (R < prob) {
				//accept the change anyway
				energy = newenergy;
				//console.log("Boltzmann probability satisfied, accepting change anyway!");
			} else {
				//reject the change by reverting back to original coordinates. update average.
				restoreFromGhost(ligand,backup);
			}
		}
		//regardless, add the current unmodified or modified energy of the iteration to the average, provided that it's not one of the first 50.
		if (i >= NUM_OUTLIER) {
				totalEnergy += energy;//add to the total if energy decreases
				if (i%10 == 0){
					//send the information to the webpage via hive every 10th iteration
					//send results to the webpage
					var progress = {
						"plotpoint":[i-NUM_OUTLIER,energy],
						"boltzmann_average":(totalEnergy/(i+1)),
						"smiles":smiles
					};
				$.send(progress);
			}//end modulo if	
		}//end outlier if
	}//end loop
	return totalEnergy/(docking_job.iterations);//boltzmann average
}



accessors: {

function cartesianProductOf() {
//better cartesian function
//usage: cartesianProductOf([1,2],[3,4],[5,6]) returns 8 arrays [1,3,6],[1,3,5] and so on.
  return Array.prototype.reduce.call(arguments, function(a, b) {
    var ret = [];
    a.forEach(function(a) {
      b.forEach(function(b) {
        ret.push(a.concat([b]));
      });
    });
    return ret;
  }, [[]]);
}

function combo(obj1,obj2){
	list=[]
    for (var i=0;i<obj1.length;i++){
        for (var j= i+1;j<obj2.length;j++){
            list.push([obj1[i],obj2[j]]);
        }
    }
    return list;
}

function threeAtomAngle(atomA,middleAtom,atomB) {
	//returns angle between three atoms in RADIANS, provided that we know the middleAtom	
	var pointA = [atomA.x,atomA.y,atomA.z];
	var pointB = [middleAtom.x,middleAtom.y,middleAtom.z];
	var pointC = [atomB.x,atomB.y,atomB.z];
	//produce unit vectors pointing away from middle atom so we divide by magnitude product of 1 when evaluating angle.
	var vector1 = vec3.normalize(vec3.subtract(pointA,pointB));
	var vector2 = vec3.normalize(vec3.subtract(pointC,pointB));
	return Math.acos(vec3.dot(vector1,vector2))
}

function VectorTorsion(pointA, pointB, pointC, pointD) {
	//ported from OpenBabel vectortorsion function.
	//create bond vectors
	
	var ij = [0,0,0];
	var jk = [0,0,0];
	var kl = [0,0,0];
	vec3.subtract(pointB,pointA,ij);
	vec3.subtract(pointC,pointB,jk);
	vec3.subtract(pointD,pointC,kl);
	
	//normalize bond vectors
	vec3.normalize(ij);
	vec3.normalize(jk);
	vec3.normalize(kl);
	//compute torsion
	
	var a = [0,0,0]
	var b = [0,0,0]
	var c = [0,0,0]
	vec3.cross(ij,jk,a);
	vec3.cross(jk,kl,b);
	vec3.cross(a,b,c);
	
	var d1 = vec3.dot(c,jk);//vec3.dot doesn't take destination variable, unlike subtract and cross. tricky
	var d2 = vec3.dot(a,b);
	var tor = RAD_TO_DEG * Math.atan2(d1,d2);//special arctangent function. We return RAD_TO_DEG to maintain similarity with OpenBabel.
	
	return tor;
}



}//end accessors


substructureSearchMethods:{
//most of these functions require metadata to be set up beforehand. otherwise they may break.

function getOtherAtom(bond,atom){
	//unfortunately the catastrophic assumption does not hold true. Code becomes all that
	//more inefficient.
	//we assume that 'atom' is in the bond.
	if (bond.a1 === atom){
		return bond.a2;
	} else if (bond.a2 === atom) {
		return bond.a1;
	} else {
		console.log("get Other atom: uh oh. atom is not in bond"); 
	}
}

function isWithinTwoBondsApart(mol,atom1,atom2) {
	//use in nonbonded interactions. returns true if two atoms are within 2 bonds of each other, otherwise returns false.
	var atomArray = getConnectedAtoms(mol,atom1);
	for (var i = 0;i<atomArray.length;i++){
		if (atom2 === atomArray[i]) {
			return true;
		}
		var secondArray = getConnectedAtoms(mol,atomArray[i]);
		for (var j=0;j<secondArray.length;j++){
			if (atom2 === secondArray[j]) {
				return true;
			}
		}
	}
	return false;
}

function isOneFour(mol,atom1,atom4) {
	//function modeled after OBabel algorithm
	//checks if atom1 and atom4 satisfy atom1 -- atom --- atom --- atom4
	var atoms_2 = getConnectedAtoms(mol,atom1);
	for (var i = 0;i<atoms_2.length;i++){
		//starting from atom 2, call the isWithinTwoBondsApart method > it should be able to reach atom 4.
		//note that for this function to be called in the first place, it cannot be 1 bond apart so we run no risk of accidentally saying 'true' for atom 3.
		var atom2 = atoms_2[i];
		if (isWithinTwoBondsApart(mol,atom2,atom4)) {
			return true;
		}
	}
	return false;
}


function hasTwoBondSequence(mol,atom,sequence){
	//atom [#7X2](=*)=*       n1    "sp1 N"
	//atom [#7X2](-*)#*       n1    "sp1 N"
	var first_bondset = mol.getBonds(atom);
	for (var i = 0;i<first_bondset.length;i++){
		//for each of these bonds, basically walk across the a2 atom if bond order satisfies first param.
		if (first_bondset[i].bondOrder == sequence[0]){
			//make a new bondset from the new reference atom, then remove first_bondset[i]
			var atom2 = getOtherAtom(first_bondset[i],atom);
			var second_bondset = mol.getBonds(atom2);
			second_bondset.splice(second_bondset.indexOf(first_bondset[i]),1);
			for (var j=0;j<second_bondset.length;j++){
				if (second_bondset[j].bondOrder==sequence[1]){
					return true;
				}
			}
		}
	}
	return false;
}

function hasTwoAndOneBondSequence(mol,atom,sequence){
	//turns out that my perception of things like [#6X2](#*)-*#*  was completely wrong
	//so now sequence will consist of [parenthesesbond,doublesequence1,doublesequence2].
	//calls hasTwobondSequence on the last 2, then calls hasBondOrder on the first one.
	//takes advantage of the fact that the queries, the first 2 are never the same so it won't repeat the search.
	//ugly hack. fix in the future.
	if (hasBondOrder(mol,atom,sequence[0]) && hasTwoBondSequence(mol,atom,[sequence[1],sequence[2]])){
		return true;
	} else {
		return false;
	}
}

function hasBondOrder(mol,atom,num){
	var ans = false;
	for (var i=0; i< atom.bondNumber;i++) {
		if (mol.getBonds(atom)[i].bondOrder == num) {
			ans = true;
		}
	}
	return ans;
}

//counters

function getMaximumBondOrder(mol,atom) {
	var ans = 1;
	for (var i=0; i< atom.bondNumber;i++) {
		if (mol.getBonds(atom)[i].bondOrder > ans) {
			ans = mol.getBonds(atom)[i].bondOrder;
		}
	}
	return ans;
}

function getHeavyValence(mol,atom) {
	//heavy valence =the sum of the bond orders of bonds to non-hydrogen neighbors.
	var count;
	var bonds = mol.getBonds(atom);
	for (var i=0;i<bonds.length;i++){
		if (getOtherAtom(bonds[i],atom).label !== 'H') {
			//not a hydrogen, so we increment the count by bond order of this bond.
			count+=bonds[i].bondOrder;	
		}
	}
	return count;
}

function getConnectedAtoms(mol,atom) {
	//handy function that returns the atoms connected to an atom. Probably useful for substructure searching.
	//we make the catastrophic assumption that a1 is always the atom that we pass in.
	//at any rate, better to make the catastrophic assumption here rather than everywhere else.
	//metadata needs to be setup first!
	var atomArray = [];
	for (var i = 0; i<atom.bondNumber;i++) {
		atomArray[i] = getOtherAtom(mol.getBonds(atom)[i],atom);
	}
	return atomArray
}

function specificNeighborCount(mol,atom,label){
	//returns how many neighbors of label 'label' the atom is bonded to. Case must match
	var count = 0;
	for (var i=0; i< atom.bondNumber;i++) {
		if (getOtherAtom(mol.getBonds(atom)[i],atom).label == label) {
			count++;
		}
	}
	return count;
}

function getNumOfBondOrder(mol,atom,order){
	var bonds = mol.getBonds(atom);
	var count = 0;
	for (var i=0;i<bonds.length;i++) {
		if (bonds[i].bondOrder == order) {
			count++;
		}
	}
	return count;
}

function getNumOfSpecificBondedAtoms(mol,atom,label) {
	//special code just for 'no' atom type
	//we assume it is a nitrogen passed in as 'atom'.
	//check if bonded to two O atoms
	var count = 0;
	var atoms = getConnectedAtoms(mol,atom);
	for (var i = 0;i<atoms.length;i++){
		if (atoms[i].label == label) {
			count++
		}
	}
	return count;
}

function hydrogenGetNumEWDBranchesOffCarbon(mol,carbon_atom){
	//it so happens that there is 1 ewd, 2 ewd, 3 ewd, etc for a bunch of different hydrogens
	//atom is presumably a hydrogen, or something bonded to a carbon atom that you want to test, and has no other bonds except for the carbon.
	//this basically returns 0 if the (carbon bonded to the hydrogen) has no EWD type 
	//atoms sticking off of it, or if the carbon doesn't exist at all.
	//returns the number of branches satisfying [#7,#8,#16,#17,#35,#53]
	//if (carbon.label !== 'C') {	return 0;}
	var atoms = getConnectedAtoms(mol,carbon_atom);
	var count = 0;
	for (var i=0;i<atoms.length;i++) {
		if (atoms[i].label == 'N'|| atoms[i].label == 'O'|| atoms[i].label == 'S'|| atoms[i].label == 'Cl'|| atoms[i].label == 'Br' || atoms[i].label == 'I'){
			count++;
		}
	}
	return count;
}

//custom checks

function NAMCheck(mol,atom) {
	//checks [$(NC=[O,S])] assuming that atom is already a hydrogen
	//nitrogen bonded to a carbon which is in turn double-bonded to an O or S.
	var array = getConnectedAtoms(mol,atom);
	for (var i = 0;i<array.length;i++) {
		if (array[i].label == 'C') {
			var bonds = mol.getBonds(array[i]);
			for (var j = 0;j<bonds.length;j++) {
				//search all bonds connected to C for double-bondedness and O or S property;
				if (bonds[j].bondOrder == 2 && (getOtherAtom(bonds[j],array[i]).label == 'O' || getOtherAtom(bonds[j],array[i]).label == 'S')) {
					if (!getOtherAtom(bonds[j],array[i]).isAromatic) {
						//check if aliphatic
						return true;
					}
				}
			}
		}
	}
	return false;
}


function sp2OxygenCheck(mol,atom) {
	//special method. a bit too complex to put in a if statement so we evaluate it here.
	//easy one:
	//[o,$(O=*)]
	
	if (atom.isAromatic || hasBondOrder(mol,atom,2)) {
		return true;
	} 
	
	//[$([#8D1][#6][#8D1])]
	//oxygen atom whose only bonded atom is a carbon atom, which is bonded to another 
	//clingy oxygen atom just like the first.	
	var array = getConnectedAtoms(mol,atom);
	
	if (atom.bondNumber == 1 && getConnectedAtoms(mol,atom)[0].label == 'C') {
		//only one atom to find so we know it's in index 0
		var ccount = 0;
		//iterate across all atoms bonded to the [0]th connected atom to O
		//if two atoms satisfy loneliness condition, then return true
		for (var i = 0;i<array.length;i++) {
			if (getConnectedAtoms(mol,getConnectedAtoms(mol,atom)[0])[i].label == 'O') {
				ccount++;
			}
		}
		if (ccount > 1) {
			//ought to be at least 2, because we count the first atom again.
			return true;
		}
	}
	
	//aliphatic O bonded to a Carbon, Nitrogen, Oxygen that is in turn 
	//double-bonded or aromatically bonded to another atom. <-- need to fix, 
	//no implementation of aromatic bonds right now. unless it's a plain ring?
	//$(O[#6,#7,#8]=,:*)
	
	//check if it is bonded to a carbon, nitrogen, or oxygen and that C,N, or O atom is double-bonded to something else. I did not separate this function
	//because the other one has a triple bond term too.
	for (var i = 0;i<array.length;i++) {
		if (array[i].label == 'C' || array[i].label == 'N' || array[i].label == 'O') {
			//if the atom is bonded to another atom (other than the origianl
			//oxygen) with a double or aromatic bond
			//then return true
			//make an array of bonds from array[i] and then remove the original bond.
			var bondarray = mol.getBonds(array[i]);//bunch of bonds
			//find the bond.
			//search through bondarray for a double bond and make sure that it isn't attached to the original atom.
			for (var j = 0;j<bondarray.length;j++) {
				if (bondarray[j].bondOrder == 2 || (getOtherAtom(bondarray[j],array[i]).isAromatic && getOtherAtom(bondarray[j],array[i]).isAromatic)) {
					if (getOtherAtom(bondarray[j],array[i]) !== atom) {	return true;}
				}
			}
		}
	}
	return false;//none of the criterion satisfied this.
}

function spNitrogenCheck(mol,atom) {
	//[$(N#*),$([ND2](=*)=*)] 
	//aliphatic triple-bonded to something.
	//aliphatic with two bonds double-bonded to an atom with another double-bond.
	if (!atom.isAromatic && hasBondOrder(mol,atom,3)) {
		return true;
	}
	
	//if not ND2, don't even bother.
	if (atom.bondNumber !== 2) {	return false;}
	//check if has two doublebonds
	if (getNumOfBondOrder(mol,atom,2)==2) {	return true};
}

function sp2NitrogenCheck(mol,atom) {
	//[n,$(N=*)]
	if (atom.isAromatic || hasBondOrder(mol,atom,2)) {	return true;}
	//[$(N[#6,#7,#8]=,:,#*)] 
	//Nitrogen bonded to C, N, or O which in turn has a double or aromatic or triple bond to any atom.
	var array = getConnectedAtoms(mol,atom);
	for (var i = 0;i<array.length;i++) {
		if (array[i].label == 'C' || array[i].label == 'N' || array[i].label == 'O') {
			//if the atom is bonded to another atom (other than the origianl
			//oxygen) with a double or aromatic bond
			//then return true
			//make an array of bonds from array[i] and then remove the original bond.
			var bondarray = mol.getBonds(array[i]);//bunch of bonds
			//find the bond.
			//search through bondarray for a double bond and make sure that it isn't attached to the original atom.
			for (var j = 0;j<bondarray.length;j++) {
				if (bondarray[j].bondOrder == 2 || bondarray[j].bondOrder == 3) {//or is aromatic bond - need to implement
					if (getOtherAtom(bondarray[j],array[i]) !== atom) {	return true;}
				}
			}
		}
	}	
	return false;//none of the criterion satisfied this.
}

function amideNCheck(mol,atom){
	//sp2 N in amides [#7X3]-[CX3]=[O,S]
	var array = getConnectedAtoms(mol,atom);
	for (var i=0;i<array.length;i++){
		if (array[i].label == 'C' && array[i].bondNumber + array[i].getImplicitHydrogenCount() == 3){
			var array2 = mol.getBonds(array[i])
			for (var j=0;j<array2.length;j++){
				if (array2[j].bondOrder == 2 &&(getOtherAtom(array2[j],array[i]).label == 'O' ||getOtherAtom(array2[j],array[i]).label == 'S')){
					return true;
				}
			}
		}
	}
	return false;
}

function amineNCheck(mol,atom) {
// atom [#7X3]a            nh    "amine N connected to aromatic ring"
// atom [#7X3]=[CX3]       nh    ""
// atom [#7X3]=[N2]        nh    ""//not valid smarts
// atom [#7X3]=[P2]        nh    ""//not valid smarts
// we already assume that it is a nitrogen with 3 total connections	
	//test for bonded to aromatic atom
	var atoms = getConnectedAtoms(mol,atom);
	for (var i=0;i<atoms.length;i++){
		if (atoms[i].isAromatic == true) {
			return true;
		}
	}
	var bonds = mol.getBonds(atom);
	for (var i=0;i<bonds.length;i++){
		if (bonds[i].bondOrder == 2 && getOtherAtom(bonds[i],atom).label == 'C' && getOtherAtom(bonds[i],atom).bondNumber + getOtherAtom(bonds[i],atom).getImplicitHydrogenCount() == 3) {
			return true;
		}
	}
	return false;
}

function doubleBondedtoOSCheck(mol,atom){
	//checks [atom]=[O,S]
	var bonds = mol.getBonds(atom);
	for (var i=0;i<bonds.length;i++) {
		if (bonds[i].bondOrder == 2 && (getOtherAtom(bonds[i],atom).label == 'O' || getOtherAtom(bonds[i],atom).label == 'S' )) {
			return true;
		}
	}
	return false;
}

}//end substructureSearchMethods


mutators: {


function setupMetadata2(mol){
	//more metadata to be set for Social Docking to work properly. port this over later to a web-worker.
	mol.check()//sets up rings and stuff and calls metadata setup too.
	setupRingMembership(mol);
	setupAromaticity(mol);//needed for hybridization
	setupHybridization(mol);//needed for partial charge
	assignGasteigerMarsiliPartialCharges(mol);
	assignAtomTypesGaff(mol);//declared in another file
	//we could assign stuff like VDWRadius and 6-12 well depth here, but it might make the mol object take up a lot more memory.
	//i figured that since we are using arrays and getting a key-value from stored JSON it's probably the same speed and slightly more compact.
}


function manualAssignMetadata(mol,atomtypes,partialCharges){
	for (var i = 0;i<mol.atoms.length;i++){
		mol.atoms[i].GaffAtomType = atomtypes[i];
		mol.atoms[i].partialCharge = partialCharges[i];
	}
}

function setupRingMembership(mol){
	//iterate through all rings, then set the ringMembership number of each atom equal to the size of the ring
	//probably a cleaner way to do this is to just put it in the ring setup function. but whatever, this is pretty easy to do.
	for (var i=0;i<mol.rings.length;i++){
		for (var j = 0;j<mol.rings[i].atoms.length;j++){
			mol.rings[i].atoms[j].ringMembership = mol.rings[i].atoms.length;
		}
	}
}

function moveMolecule(mol,vectorxyz) {
	//iterate through all atoms in the molecule
	//moving utilities for docking algorithm
	
	//moving an atom.
	//p = {'x':0,'y':0,'z':0};
	//add3D function will add the vector p to coordinates of atom.
	for (var i = 0; i<mol.atoms.length;i++) {
		mol.atoms[i].add3D(vectorxyz);
	}
}


function montecarlomove(ligand,starting_point) {
	//move the whole molecule
	var deltaX = MAX_MOL_TRANSLATE*( 2.0 * Math.random() - 1.0 );
	var deltaY = MAX_MOL_TRANSLATE*( 2.0 * Math.random() - 1.0 );
	var deltaZ = MAX_MOL_TRANSLATE*( 2.0 * Math.random() - 1.0 );
	moveMolecule(ligand,{'x':deltaX,'y':deltaY,'z':deltaZ});
	//move each atom a bit.
	for (var i=0;i<ligand.atoms.length;i++){
		//create random vector, make sure that the move does not bring any of the atoms out of the box:	
		var delta_x = MAX_ATOM_TRANSLATE*( 2.0 * Math.random() - 1.0 );
		var delta_y = MAX_ATOM_TRANSLATE*( 2.0 * Math.random() - 1.0 );
		var delta_z = MAX_ATOM_TRANSLATE*( 2.0 * Math.random() - 1.0 );
		var vectorxyz = {'x':delta_x,'y':delta_y,'z':delta_z};//ChemDoodle, not glMatrix vector
		ligand.atoms[i].add3D(vectorxyz);
		//out of bounds check
		wrapPointIfOutOfBounds(ligand.atoms[i],starting_point);
	}
	
}



function wrapPointIfOutOfBounds(atom,starting_point){
	if (atom.x < starting_point[0]-BOXSIZE) {
		atom.x = starting_point[0]-BOXSIZE;
	} else if (atom.x > starting_point[0]+BOXSIZE) {
		atom.x = starting_point[0]+BOXSIZE;
	}
	if (atom.y < starting_point[1]-BOXSIZE) {
		atom.y = starting_point[1]-BOXSIZE;
	} else if (atom.y > starting_point[1]+BOXSIZE) {
		atom.y = starting_point[1]+BOXSIZE;
	}
	if (atom.z < starting_point[2]-BOXSIZE) {
		atom.z = starting_point[2]-BOXSIZE;
	} else if (atom.z > starting_point[2]+BOXSIZE) {
		atom.z = starting_point[2]+BOXSIZE;
	}
}

function moveMoleculeTo(mol,destination){
	var displacement = [0,0,0];
	var center = mol.getCenter3D();
	vec3.subtract(destination,[center.x,center.y,center.z],displacement);
	//add the displacement vector to every atom in molecule to position ligand.
	//be careful with the alternate vector definitions
	var vectorxyz = {'x':displacement[0],'y':displacement[1],'z':displacement[2]};
	moveMolecule(mol,vectorxyz);
}

function ghostcopy(mol) {
	var thecopy=[];//a simple array of the coordinates of each atom
	for (var i=0;i<mol.atoms.length;i++){
		thecopy.push([mol.atoms[i].x,mol.atoms[i].y,mol.atoms[i].z]);
	}
	return thecopy;
}

function restoreFromGhost(mol,ghost) {
	//restore from a ghost backup of coordinates
	for (var i=0;i<ghost.length;i++){
		mol.atoms[i].x = ghost[i][0];
		mol.atoms[i].y = ghost[i][1];
		mol.atoms[i].z = ghost[i][2];
	}
}


}//end mutator functions


